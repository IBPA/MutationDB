library(nnet)
library(ROCR)
library(doParallel)
setwd("/home/minseven/taglab/XK/mutation/output")
detectCores()
cl <- makeCluster(3)
registerDoParallel(cl)
getDoParWorkers()
install.packages("bigGP")
install.packages("bigGP")
install.packages("C:/Users/wmmkx_000/Downloads/bigGP_0.1-6.tar.gz", repos = NULL, type = "source")
install.packages("rmpi")
library(Rmpi)
library("Rmpi")
install.packages("Rmpi")
library("Rmpi")
library("Rmpi")
library(Rmpi)
library(Rmpi)
library(Rmpi)
library(Rmpi)
install.packages("Rmpi")
library(Rmpi)
install.packages("MPICH2")
library(MPICH2)
install.packages("multicore")
library(multcore)
library(Rmpi)
?Rprofile
Sys.getenv()
Sys.getenv(names=R_SHARE_DIR)
Sys.getenv(names="R_SHARE_DIR")
R.home(component = "home")
library(Rmpi)
#http://www.r-bloggers.com/accelerating-r-with-multi-node-parallelism-rmpi-batchjobs-and-openlava/
library(ggplot2)
x=1000000
d1 = matrix(rnorm(x, mean = 0, sd = 1),ncol=x/2)
d2 = matrix(rnorm(x, mean = 5, sd = 1),ncol=x/2)
d = t(data.frame(d1,d2))
start.time <- Sys.time()
cl = kmeans(d,2,nstart=5)
start.time <- Sys.time()
cl = kmeans(d,2,nstart=5)
end.time <- Sys.time()
end.time - start.time
x=2000000
d1 = matrix(rnorm(x, mean = 0, sd = 1),ncol=x/2)
d2 = matrix(rnorm(x, mean = 5, sd = 1),ncol=x/2)
d = t(data.frame(d1,d2))
write.csv(d,"dataset.csv",row.names=FALSE)
start.time <- Sys.time()
cl = kmeans(d,2,nstart=5)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
x=500000
d1 = matrix(rnorm(x, mean = 0, sd = 1),ncol=x/2)
d2 = matrix(rnorm(x, mean = 5, sd = 1),ncol=x/2)
d = t(data.frame(d1,d2))
start.time <- Sys.time()
cl = kmeans(d,2,nstart=5)
end.time <- Sys.time()
time.taken <- end.time - start.time
print(time.taken)
print(cl$centers)
plot(d,col = cl$cluster+2)
setwd("C:/Users/wmmkx_000/Dropbox/Indexed Paper/DB/stage 4 feature selection/ANN_score")
library(ROCR)
df=read.csv("ANN_mutation.csv",header=TRUE)
ROC = list()
P_R = list()
j =1
for (j in 1:(dim(df)[2]-1))
{
trigger = file.exists(paste("score",j,".csv",sep=""))
if (trigger==FALSE){
cat(j)
next
}
score = read.csv(file=paste("score",j,".csv",sep=""))
actual_class <- df[,j]
}
read.csv(file=paste("score",j,".csv",sep=""))
test = read.csv(file=paste("score",j,".csv",sep=""))
dim(test)
score = max(nrow=dim(mut)[1], ncol = dim(mut)[2])
mut=df[,c(-9,-dim(df)[2])]
score = max(nrow=dim(mut)[1], ncol = dim(mut)[2])
score[,i] = read.csv(file=paste("score",j,".csv",sep=""))
i=1
score[,i] = read.csv(file=paste("score",j,".csv",sep=""))
a = read.csv(file=paste("score",j,".csv",sep=""))
score[,i] = a[,1]
dim(a)
i
score
score = max(nrow=dim(mut)[1], ncol = dim(mut)[2])
score
score = marixx(nrow=dim(mut)[1], ncol = dim(mut)[2])
score = matrix(nrow=dim(mut)[1], ncol = dim(mut)[2])
a = read.csv(file=paste("score",j,".csv",sep=""))
score[,i] = a[,1]
score[,i] = read.csv(file=paste("score",j,".csv",sep=""))
score
score = matrix(nrow=dim(mut)[1], ncol = dim(mut)[2])
score
a = read.csv(file=paste("score",j,".csv",sep=""))
score[,i] = a[,1]
score
library(ROCR)
df=read.csv("ANN_mutation.csv",header=TRUE)
ROC = list()
P_R = list()
mut=df[,c(-9,-dim(df)[2])]
score = matrix(nrow=dim(mut)[1], ncol = dim(mut)[2])
j =1
i=1
for (j in 1:(dim(df)[2]-1))
{
trigger = file.exists(paste("score",j,".csv",sep=""))
if (trigger==FALSE){
cat(j)
next
}
a = read.csv(file=paste("score",j,".csv",sep=""))
score[,i] = a[,1]
i = i+1
}
j
i =1
pred <- prediction(score[i,], mut[i,])
name_pred = slotNames(pred)
check = slot(pred,name_pred[5])[[1]]
if (sum(check)==0){
next
}
perf <- performance(pred, "tpr", "fpr")
names = slotNames(perf)
ROC[[2*j-1]]=slot(perf,names[4])[[1]]  # False positive rate
ROC[[2*j]]=slot(perf,names[5])[[1]]    # True positive rate
pred <- prediction(score[i,], mut[i,])
length(score[i,])
length(mut[i,])
pred <- prediction(score[i,], mut[i,])
mut[1,]
score[1,]
which(mut[1,]==1)
library(ROCR)
pred <- prediction(score[i,], mut[i,])
str(mut[,1])
str(mut[1,])
str(mut[,1])
unlist(mut[i,])
str(unlist(mut[i,]))
pred <- prediction(score[i,], unlist(mut[i,]))
j =1
for (i in 1:dim(mut)[1])
{
pred <- prediction(score[i,], unlist(mut[i,]))
name_pred = slotNames(pred)
check = slot(pred,name_pred[5])[[1]]
if (sum(check)==0){
next
}
perf <- performance(pred, "tpr", "fpr")
names = slotNames(perf)
ROC[[2*j-1]]=slot(perf,names[4])[[1]]  # False positive rate
ROC[[2*j]]=slot(perf,names[5])[[1]]    # True positive rate
P_num = length(which(actual_class==1))
N_num = length(which(actual_class==0))
TP_num = ROC[[2*j]]*P_num
FP_num = N_num - (1-ROC[[2*j-1]])*N_num  # how many real negative is predicted to be positive
precision = TP_num/(TP_num+FP_num)
P_R[[2*j]]=precision
P_R[[2*j-1]] =ROC[[2*j]]
}
j
i
which(mut[201,]==1)
j =1
for (j in 1:dim(mut)[1])
{
tryCatch({
pred <- prediction(score[j,], unlist(mut[j,]))
name_pred = slotNames(pred)
check = slot(pred,name_pred[5])[[1]]
if (sum(check)==0){
next
}
perf <- performance(pred, "tpr", "fpr")
names = slotNames(perf)
ROC[[2*j-1]]=slot(perf,names[4])[[1]]  # False positive rate
ROC[[2*j]]=slot(perf,names[5])[[1]]    # True positive rate
P_num = length(which(actual_class==1))
N_num = length(which(actual_class==0))
TP_num = ROC[[2*j]]*P_num
FP_num = N_num - (1-ROC[[2*j-1]])*N_num  # how many real negative is predicted to be positive
precision = TP_num/(TP_num+FP_num)
P_R[[2*j]]=precision
P_R[[2*j-1]] =ROC[[2*j]]
},error=function(e){cat(j,"\n","error","\n")})
}
# get rid of null
num_roc = as.numeric()
Notnull = list()
Notnull_PR = list()
j = 1
for (i in 1:length(ROC))
{
if (!is.null(ROC[[i]]))
{
Notnull[[j]]=ROC[[i]]
Notnull_PR[[j]] = P_R[[i]]
j = j+1
}
}
interpolate
inter_roc = list()
inter_PR = list()
i=1
for (i in 1:(length(Notnull)/2))  #
{
tryCatch({
x = Notnull[[2*i-1]]
y = Notnull[[2*i]]
interpolate  = approx(x,y)
#png(file=paste("ROC", i, ".png",sep=""))
#plot(x,y)
#dev.off()
inter_roc[[2*i-1]] = interpolate$x
inter_roc[[2*i]] = interpolate$y
x = Notnull_PR[[2*i-1]][2:length(Notnull_PR[[2*i-1]])]
y = Notnull_PR[[2*i]][2:length(Notnull_PR[[2*i]])]
# png(file=paste("PR", i, ".png",sep=""))
#plot(x,y)
#dev.off()
interpolate  = approx(x,y)
#png(file=paste("inter_PR", i, ".png",sep=""))
#plot(interpolate$x,interpolate$y,type="l")
#dev.off()
inter_PR[[2*i-1]] = interpolate$x
inter_PR[[2*i]] = interpolate$y
},error=function(e){cat(i,"\n","error","\n")})
}
# get rid of null that was generated in interpolation
i=1
j = 1
Notnull_in_PR = list()
for (i in 1:length(inter_PR))
{
if (!is.null(inter_PR[[i]]))
{
Notnull_in_PR[[j]]=inter_PR[[i]]
j = j+1
}
}
i=1
FPR = inter_roc[[1]]
TPR = inter_roc[[2]]
for (i in 2:(length(Notnull)/2))  #
{
FPR = FPR+inter_roc[[2*i-1]]
TPR = TPR+inter_roc[[2*i]]
}
i=1
Precision = Notnull_in_PR[[2]]
Recall = Notnull_in_PR[[1]]
for (i in 2:(length(Notnull_in_PR)/2))  #
{
Precision = Precision + Notnull_in_PR[[2*i]]
Recall = Recall + Notnull_in_PR[[2*i-1]]
}
FPR = FPR/( length(Notnull)/2)
TPR = TPR/( length(Notnull)/2)
Precision = Precision /(length(Notnull_in_PR)/2)
Recall = Recall / (length(Notnull_in_PR)/2)
ROC_out = data.frame(FPR,TPR)
PR_out = data.frame(Recall,Precision)
plot(FPR,TPR)
plot(Recall,Precision)
setwd("C:/Users/wmmkx_000/Dropbox/Indexed Paper/DB/stage 4 feature selection/ANN_score")
library(ROCR)
df=read.csv("ANN_mutation.csv",header=TRUE)
ROC = list()
P_R = list()
mut=df[,c(-9,-dim(df)[2])]
score = matrix(nrow=dim(mut)[1], ncol = dim(mut)[2])
j =1
i=1
for (j in 1:(dim(df)[2]-1))
{
trigger = file.exists(paste("score",j,".csv",sep=""))
if (trigger==FALSE){
cat(j)
next
}
a = read.csv(file=paste("score",j,".csv",sep=""))
score[,i] = a[,1]
i = i+1
}
j =1
for (j in 1:dim(mut)[1])
{
tryCatch({
pred <- prediction(score[j,], unlist(mut[j,]))
name_pred = slotNames(pred)
check = slot(pred,name_pred[5])[[1]]
if (sum(check)==0){
next
}
perf <- performance(pred, "tpr", "fpr")
names = slotNames(perf)
ROC[[2*j-1]]=slot(perf,names[4])[[1]]  # False positive rate
ROC[[2*j]]=slot(perf,names[5])[[1]]    # True positive rate
P_num = length(which(actual_class==1))
N_num = length(which(actual_class==0))
TP_num = ROC[[2*j]]*P_num
FP_num = N_num - (1-ROC[[2*j-1]])*N_num  # how many real negative is predicted to be positive
precision = TP_num/(TP_num+FP_num)
P_R[[2*j]]=precision
P_R[[2*j-1]] =ROC[[2*j]]
},error=function(e){cat(j,"\n","error","\n")})
}
#calculate ROC and precision_recall is done
# get rid of null
num_roc = as.numeric()
Notnull = list()
Notnull_PR = list()
j = 1
for (i in 1:length(ROC))
{
if (!is.null(ROC[[i]]))
{
Notnull[[j]]=ROC[[i]]
Notnull_PR[[j]] = P_R[[i]]
j = j+1
}
}
# interpolate
inter_roc = list()
inter_PR = list()
i=1
for (i in 1:(length(Notnull)/2))  #
{
tryCatch({
x = Notnull[[2*i-1]]
y = Notnull[[2*i]]
interpolate  = approx(x,y)
#png(file=paste("ROC", i, ".png",sep=""))
#plot(x,y)
#dev.off()
inter_roc[[2*i-1]] = interpolate$x
inter_roc[[2*i]] = interpolate$y
x = Notnull_PR[[2*i-1]][2:length(Notnull_PR[[2*i-1]])]
y = Notnull_PR[[2*i]][2:length(Notnull_PR[[2*i]])]
# png(file=paste("PR", i, ".png",sep=""))
#plot(x,y)
#dev.off()
interpolate  = approx(x,y)
#png(file=paste("inter_PR", i, ".png",sep=""))
#plot(interpolate$x,interpolate$y,type="l")
#dev.off()
inter_PR[[2*i-1]] = interpolate$x
inter_PR[[2*i]] = interpolate$y
},error=function(e){cat(i,"\n","error","\n")})
}
# get rid of null that was generated in interpolation
i=1
j = 1
Notnull_in_PR = list()
for (i in 1:length(inter_PR))
{
if (!is.null(inter_PR[[i]]))
{
Notnull_in_PR[[j]]=inter_PR[[i]]
j = j+1
}
}
i=1
FPR = inter_roc[[1]]
TPR = inter_roc[[2]]
for (i in 2:(length(Notnull)/2))  #
{
FPR = FPR+inter_roc[[2*i-1]]
TPR = TPR+inter_roc[[2*i]]
}
i=1
Precision = Notnull_in_PR[[2]]
Recall = Notnull_in_PR[[1]]
for (i in 2:(length(Notnull_in_PR)/2))  #
{
Precision = Precision + Notnull_in_PR[[2*i]]
Recall = Recall + Notnull_in_PR[[2*i-1]]
}
FPR = FPR/( length(Notnull)/2)
TPR = TPR/( length(Notnull)/2)
Precision = Precision /(length(Notnull_in_PR)/2)
Recall = Recall / (length(Notnull_in_PR)/2)
ROC_out = data.frame(FPR,TPR)
PR_out = data.frame(Recall,Precision)
plot(FPR,TPR)
plot(Recall,Precision)
